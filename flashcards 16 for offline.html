<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ukrainian Mastery SRS</title>
<link rel="manifest" href="data:application/manifest+json,{%22name%22:%22UA-SRS%22,%22short_name%22:%22UA-SRS%22,%22start_url%22:%22.%22,%22display%22:%22standalone%22,%22background_color%22:%22#1f2937%22}">
<script type="module">
  import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm';
  const SUPABASE_URL = 'https://igbhbmeyhhddnlyntnwz.supabase.co';
  const SUPABASE_KEY = 'sb_publishable_vJQLZQsNjIRpTlVPzsoJww_IdUX_z2V';
  const supabase = createClient(SUPABASE_URL, SUPABASE_KEY);
  window.srsApp = { supabase };
</script>
<style>
/* CSS remains the same as before */
body{font-family:Arial,sans-serif;background:#1f2937;color:white;margin:0}
.container{max-width:700px;margin:auto;padding:20px}
.card{background:#374151;padding:25px;border-radius:14px;text-align:center;min-height:200px;position:relative}
.front{font-size:30px;margin-bottom:20px}
.back{font-size:28px;margin:15px 0;color:#34d399;display:none}
button{padding:12px 20px;margin:6px;border:none;border-radius:8px;font-size:16px;cursor:pointer}
.primary{background:#2563eb;color:white}
.secondary{background:#4b5563;color:white}
.record-btn{background:#ef4444;color:white}
.clear-btn{background:#6b7280;color:white;font-size:12px}
.star{font-size:36px;cursor:pointer;margin:8px}
.hidden{display:none}
textarea{width:100%;height:130px;margin-top:10px;background:#1f2937;color:white;border:1px solid #4b5563;padding:10px}
.menu{text-align:center;margin-bottom:10px}
select,input{padding:10px;border-radius:6px;border:none;margin:4px;width:100%;background:#4b5563;color:white}
#offlineStatus { position: absolute; top: 10px; right: 15px; font-size: 14px; opacity: 0.7; display: flex; align-items: center; gap: 5px; }
#revealBtn { font-size: 40px; padding: 15px 40px; background: #2563eb; width: 100%; }
</style>
</head>
<body>
<div class="container">
<div class="menu">
<button id="importBtn" class="secondary">Import Text</button>
<button id="settingsBtn" class="secondary">Settings</button>
</div>
<div id="card" class="card">
<div id="offlineStatus"><span id="unsyncedCount"></span><span id="offlineIcon">üì°</span></div>
<div id="front" class="front">Loading...</div>
<button id="revealBtn" class="primary">üôÇ</button>
<div id="back" class="back"></div>
<div id="actionButtons" class="hidden">
  <button id="audioBtn" class="primary">üîä Play</button>
  <button id="recordBtn" class="record-btn">üé§ Record</button>
  <button id="clearAudioBtn" class="clear-btn hidden">üóëÔ∏è Clear</button>
</div>
<div id="stars" class="hidden"></div>
</div>
</div>

<script>
// --- SERVICE WORKER REGISTRATION ---
if ('serviceWorker' in navigator) {
  const swCode = `
    const cacheName = 'srs-v1';
    self.addEventListener('install', e => {
      e.waitUntil(caches.open(cacheName).then(cache => cache.addAll(['./', 'index.html'])));
    });
    self.addEventListener('fetch', e => {
      e.respondWith(caches.match(e.request).then(res => res || fetch(e.request)));
    });
  `;
  const blob = new Blob([swCode], {type: 'text/javascript'});
  navigator.serviceWorker.register(URL.createObjectURL(blob));
}
</script>

<script type="module">
// All the logic from the previous version goes here 
// (indexedDB, rate, audio, sync, etc.)
// ... 

const { supabase } = window.srsApp;
let db;
let unsyncedLocalCount = 0;
let mediaRecorder;
let audioChunks = [];

const request = indexedDB.open('FlashcardDB', 1);
request.onupgradeneeded = (e) => {
  db = e.target.result;
  if (!db.objectStoreNames.contains('cards')) db.createObjectStore('cards', { keyPath: 'id' });
};
request.onsuccess = (e) => { db = e.target.result; loadDecks(); loadTodayCard(); };

let currentCard = null;
let currentDeck = 'All';
const front = document.getElementById('front');
const back = document.getElementById('back');
const revealBtn = document.getElementById('revealBtn');
const audioBtn = document.getElementById('audioBtn');
const recordBtn = document.getElementById('recordBtn');
const clearAudioBtn = document.getElementById('clearAudioBtn');
const actionButtons = document.getElementById('actionButtons');
const starsDiv = document.getElementById('stars');
const offlineIcon = document.getElementById('offlineIcon');
const unsyncedSpan = document.getElementById('unsyncedCount');

function today(){return new Date().toISOString().split('T')[0];}
function updateSyncDisplay() {
  offlineIcon.style.display = navigator.onLine ? 'none' : 'block';
  unsyncedSpan.innerText = unsyncedLocalCount > 0 ? unsyncedLocalCount : '';
}

async function loadDecks(){
  if (db) {
    const tx = db.transaction('cards', 'readonly');
    const store = tx.objectStore('cards');
    const req = store.getAll();
    req.onsuccess = () => updateDeckUI(['All', ...new Set(req.result.map(d=>d.deck||'Default'))]);
  }
}

function updateDeckUI(decks) {
  const sel = document.getElementById('deckSelect');
  sel.innerHTML='';
  decks.forEach(d=>{ const opt=document.createElement('option'); opt.value = d; opt.textContent=d; sel.appendChild(opt); });
}

async function loadTodayCard(){
  updateSyncDisplay();
  if (db) {
    const tx = db.transaction('cards', 'readonly');
    const store = tx.objectStore('cards');
    const req = store.getAll();
    req.onsuccess = () => displayNextCard(req.result);
  }
}

function displayNextCard(data) {
  let filtered = (currentDeck==='All') ? data : data.filter(c=>(c.deck||'Default')===currentDeck);
  const due = filtered.filter(c=>!c.next_review_date || c.next_review_date<=today());
  if(due.length===0){
    front.innerText='No cards due.'; back.style.display='none';
    revealBtn.style.display = 'none'; actionButtons.classList.add('hidden'); starsDiv.classList.add('hidden');
    return;
  }
  currentCard = due[Math.floor(Math.random()*due.length)];
  front.innerText=currentCard.english_text;
  back.style.display='none'; revealBtn.style.display = 'block';
  actionButtons.classList.add('hidden'); starsDiv.classList.add('hidden');
}

revealBtn.onclick=()=>{
  back.innerText=currentCard.ukrainian_text;
  back.style.display='block'; revealBtn.style.display = 'none';
  actionButtons.classList.remove('hidden'); 
  clearAudioBtn.classList.toggle('hidden', !currentCard.audio_base64);
  showStars();
};

function showStars(){
  starsDiv.innerHTML=''; starsDiv.classList.remove('hidden');
  [1,5,17,43,89].forEach((d,i)=>{
    const s=document.createElement('span'); s.innerText='ü¶î'; s.className='star';
    s.onclick=()=>rate(d,i+1); starsDiv.appendChild(s);
  });
}

async function rate(days,level){
  currentCard.next_review_date = new Date(Date.now() + days*86400000).toISOString().split('T')[0];
  currentCard.familiarity_level = level;
  currentCard.last_reviewed_date = new Date().toISOString();
  const tx = db.transaction('cards', 'readwrite');
  tx.objectStore('cards').put(currentCard);
  if (navigator.onLine) await supabase.from('flashcards').upsert(currentCard);
  else { unsyncedLocalCount++; updateSyncDisplay(); }
  loadTodayCard();
}

audioBtn.onclick=()=>{
  if(currentCard.audio_base64) {
    const audio = new Audio(currentCard.audio_base64);
    audio.play();
  } else {
    const u=new SpeechSynthesisUtterance(currentCard.ukrainian_text);
    const voice=speechSynthesis.getVoices().find(v=>v.lang.includes('uk'));
    if(voice) u.voice=voice;
    speechSynthesis.speak(u);
  }
};

recordBtn.onclick = async () => {
  if (mediaRecorder && mediaRecorder.state === "recording") {
    mediaRecorder.stop();
    return;
  }
  
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    mediaRecorder = new MediaRecorder(stream);
    audioChunks = [];
    
    mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
    mediaRecorder.onstop = async () => {
      const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
      const reader = new FileReader();
      reader.readAsDataURL(audioBlob);
      reader.onloadend = async () => {
        currentCard.audio_base64 = reader.result;
        const tx = db.transaction('cards', 'readwrite');
        tx.objectStore('cards').put(currentCard);
        if (navigator.onLine) await supabase.from('flashcards').upsert(currentCard);
        else { unsyncedLocalCount++; updateSyncDisplay(); }
        recordBtn.innerText = "üé§ Record";
        recordBtn.style.background = "#ef4444";
        clearAudioBtn.classList.remove('hidden');
        alert("Recording saved!");
      };
    };
    
    mediaRecorder.start();
    recordBtn.innerText = "üõë Stop";
    recordBtn.style.background = "#4b5563";
  } catch (err) {
    alert("Microphone error: " + err.message);
  }
};

clearAudioBtn.onclick = async () => {
  if(confirm("Clear recording?")) {
    delete currentCard.audio_base64;
    const tx = db.transaction('cards', 'readwrite');
    tx.objectStore('cards').put(currentCard);
    if (navigator.onLine) await supabase.from('flashcards').upsert(currentCard);
    clearAudioBtn.classList.add('hidden');
    alert("Recording cleared. Reverting to computer voice.");
  }
};

document.getElementById('syncBtn').onclick = async () => {
  if (!navigator.onLine) return alert("You must be online to synchronize.");
  const req = db.transaction('cards', 'readonly').objectStore('cards').getAll();
  req.onsuccess = async () => {
    const { error } = await supabase.from('flashcards').upsert(req.result);
    if (!error) { alert("Sync successful!"); unsyncedLocalCount = 0; updateSyncDisplay(); loadDecks(); loadTodayCard(); }
  };
};

document.getElementById('doImport').onclick = async () => {
  const text = document.getElementById('importText').value.trim();
  const lines = text.split('\n');
  let cardsToSave = lines.map(line => {
    const parts = line.split(',').map(p => p.trim());
    if(parts.length < 2) return null;
    return { id: crypto.randomUUID(), english_text: parts[0], ukrainian_text: parts[1], deck: parts[2] || 'Default', familiarity_level: 0, next_review_date: '2000-01-01' };
  }).filter(c => c !== null);
  
  const tx = db.transaction('cards', 'readwrite');
  cardsToSave.forEach(c => tx.objectStore('cards').put(c));
  if (navigator.onLine) await supabase.from('flashcards').upsert(cardsToSave);
  else { unsyncedLocalCount += cardsToSave.length; updateSyncDisplay(); }
  alert(`Imported ${cardsToSave.length} cards.`);
  loadDecks(); loadTodayCard();
};

document.getElementById('importBtn').onclick=()=>document.getElementById('importBox').classList.toggle('hidden');
document.getElementById('settingsBtn').onclick=()=>document.getElementById('settingsBox').classList.toggle('hidden');
</script>
</body>
</html>

